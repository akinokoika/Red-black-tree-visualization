<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='screen' href='./paper/paper.min.css'>
    <script src='./konva/konva.min.js'></script>
    <script src='./konva/KonvaPlugin.js'></script>
    <script src='./konva/TweenLite.min.js'></script>
    <script src='./konva/TimelineLite.min.js'></script>
    <script src='./vue/vue.global.js'></script>
</head>
<body>
    
    <div id="handle" class="row flex-center">
        <article class="article">
            <p><label for="show">{{ info }}</label><p>
        </article>
        <div id="show-box" class="sm-3 col">
            <input v-model="info" type="number" min="1" max="999">
        </div>
        <div class="sm-4 col">
            <button @click="hinsert" class="border border-danger btn-danger-outline" :disabled="!info">insert</button>
            <button @click="hdel" class="border border-danger btn-danger-outline" :disabled="!info">del</button>
        </div>
        <article class="article">
            <p class="article-meta"><span class="badge" :class={success:nature_4}>{{ nature_4 }}</span> Properties 4 (children of red are black)</p>
            <p class="article-meta"><span class="badge" :class={success:nature_5}>{{ nature_5 }}</span> Properties 5 (same number of black on path)</p>
        </article>
    </div>
    <div id="box"></div>

    <script>
        const handle = Vue.createApp({
            data() {
                return {
                    info: '',
                    nature_4: '',
                    nature_5: '',
                }
            },
            methods: {
                hinsert() {
                    t = insert(Number(this.info), t)
                    layer.destroyChildren()
                    draw(t,0,0)
                    stage.batchDraw()
                    drag(t)
                    this.nature_4 = judge_nature_4(t)
                    this.nature_5 = judge_nature_5(t)

                    console.log(t)
                    console.log(judge_nature_4(t))
                    console.log(judge_nature_5(t))
                },
                hdel() {
                    t = del(Number(this.info), t)
                    layer.destroyChildren()
                    draw(t,0,0)
                    stage.batchDraw()
                    drag(t)
                    this.nature_4 = judge_nature_4(t)
                    this.nature_5 = judge_nature_5(t)
                    
                    console.log(t)
                    console.log(judge_nature_4(t))
                    console.log(judge_nature_5(t))
                },
                drag_switch(layer){
                    var groups = layer.find('Group');
                    groups.forEach(element => {
                        element.draggable(!element.draggable());
                    });
                }
            },
        }).mount('#handle')

        const black = 'black', red = 'red', nullnode = null, ll = 'll', rr = 'rr'

        class vector{
            constructor(x = 0, y = 0, radius = null, angle = null){
                if(radius == null && angle == null){
                    this.x = x,
                    this.y = y
                }else{
                    let pox = (x + radius * Math.cos(angle * Math.PI / 180))
                    this.x = Math.round(pox)
                    let poy = (y + radius * Math.sin(angle * Math.PI / 180))
                    this.y = Math.round(poy)
                }
            }
        }
        class matrix_2by2{
            constructor(i_x = 1, i_y = 0, j_x = 0, j_y = 1){
                this.i_x = i_x,
                this.i_y = i_y,
                this.j_x = j_x,
                this.j_y = j_y
            }
            addition(vec1, vec2){
                return [vec1.x + vec2.x, vec1.y + vec2.y]
            }
            subtraction(vec1 ,vec2){
                return [vec1.x - vec2.x, vec1.y - vec2.y]
            }
        }

        class rbnode{
            constructor(d,c,l,r,p){
                this.data = d
                this.color = c
                this.left = l
                this.right = r
                this.parent = p

                this.group = null
                this.left_arrow = null
                this.right_arrow = null
                this.left_points = null
                this.right_points = null
            }
        }

        function init(){
            var root = new rbnode(-1,black,nullnode,nullnode,nullnode)
            return root
        }

        function rotate(kg, direction) {
            rotate_cartoon(kg, direction)
            var kf, kgf
            if (direction == ll)
            {
                kf = kg.right;
                kg.right = kf.left;
                if(kf.left != nullnode)
                {
                    kf.left.parent = kg;
                }
                kf.left = kg;
            }
            if (direction == rr)
            {
                kf = kg.left;
                kg.left = kf.right;
                if(kf.right != nullnode)
                {
                    kf.right.parent = kg;
                }
                kf.right = kg;
            }

            if (kg.parent == kg)
            {
                kf.parent = kf;
                kg.parent = kf;
            }
            else
            {
                kgf = kg.parent;
                if (kgf.left == kg)
                {
                    kgf.left = kf;
                }
                if (kgf.right == kg)
                {
                    kgf.right = kf;
                }
                kf.parent = kgf;
                kg.parent = kf;

                while (kf.parent != kf)
                {
                    kf = kf.parent;
                }
            }

            return kf;
        }

        function insert(x, root){
            var h, f, g, u, p
            if (root.parent == nullnode)
            {
                root.data = x;
                root.parent = root;
                return root;
            }
            var h = new rbnode(x,red,nullnode,nullnode,nullnode)
            p = root;
            while (1)
            {
                if (x < p.data)
                {
                    if (p.left == nullnode)
                    {
                        p.left = h;
                        h.parent = p;
                        break;
                    }
                    else
                    {
                        p = p.left;
                    }
                }
                if (x > p.data)
                {
                    if (p.right == nullnode)
                    {
                        p.right = h;
                        h.parent = p;
                        break;
                    }
                    else
                    {
                        p = p.right;
                    }
                }
                if (x == p.data)
                {
                    return root;
                }
            }

            while (1)
            {
                f = h.parent;
                if (f == h)
                {
                    h.color = black;
                }
                if (f.color == black)
                {
                    break;
                }
                if (f.color == red)
                {
                    g = h.parent.parent;
                    if (g.left == f)
                    {
                        u = g.right;
                    }
                    if (g.right == f)
                    {
                        u = g.left;
                    }

                    if (u == nullnode || u.color == black)
                    {
                        if (g.right == f && f.right == h)
                        {
                            root = rotate(g, ll);
                            f.color = black;
                            g.color = red;
                            break;
                        }
                        if (g.left == f && f.left == h)
                        {
                            root = rotate(g, rr);
                            f.color = black;
                            g.color = red;
                            break;
                        }
                        if (g.right == f && f.left == h)
                        {
                            root = rotate(f, rr);
                            root = rotate(g, ll);
                            h.color = black;
                            g.color = red;
                            break;
                        }
                        if (g.left == f && f.right == h)
                        {
                            root = rotate(f, ll);
                            root = rotate(g, rr);
                            h.color = black;
                            g.color = red;
                            break;
                        }
                    }

                    if (u.color == red)
                    {
                        f.color = u.color = black;
                        g.color = red;
                        h = g;
                    }
                }
            }
            return root;
        }

        function findnode(x, fn)
        {
            while (1)
            {
                if (fn == nullnode || fn.parent == nullnode)
                {
                    return fn;
                }
                if (x > fn.data)
                {
                    fn = fn.right;
                    continue;
                }
                if (x < fn.data)
                {
                    fn = fn.left;
                    continue;
                }
                if (fn != nullnode && x == fn.data)
                {
                    break;
                }
            }
            return fn;
        }

        function nextnode(r)
        {
            if (r.right == nullnode)
            {
                while (r != r.parent.left)
                {
                    r = r.parent;
                }
                r = r.parent;
            }
            else
            {
                r = r.right;
                while (r.left != nullnode)
                {
                    r = r.left;
                }
            }
            return r;
        }

        function del(x, root)
        {
            var p, r, f, b, c;

            p = findnode(x, root);
            if (p == root){
                root = init();
            }
            if (p == nullnode || root.parent == nullnode)
            {
                return root;
            }
            if (p.left != nullnode && p.right != nullnode)
            {
                r = nextnode(p);
                p.data = r.data;
                p = r;
            }
            else if (p.left != nullnode || p.right != nullnode)
            {
                if (p.left != nullnode)
                {
                    p.data = p.left.data;
                    p = p.left;
                }
                else if (p.right != nullnode)
                {
                    p.data = p.right.data;
                    p = p.right;
                }
            }
            if (p.color == black)
            {
                f = p.parent;
                if (f.left == p)
                {
                    b = f.right;
                }
                else if (f.right == p)
                {
                    b = f.left;
                }
                if (b.color == red)
                {
                    if (f.left == p)
                    {
                        b.color = black;
                        b.left.color = red;
                        root = rotate(f, ll);
                    }
                    else if (f.right == p)
                    {
                        b.color = black;
                        b.right.color = red;
                        root = rotate(f, rr);
                    }
                }
                if (b.color == black)
                {
                    if (b.left != nullnode && b.right == nullnode)
                    {
                        if (f.left == p)
                        {
                            b.left.color = black;
                            b.color = red;
                            root = rotate(b, rr);
                            b = f.right;
                        }
                        else if (f.right == p)
                        {
                            b.right.color = black;
                            b.color = red;
                            root = rotate(b, ll);
                            b = f.left;
                        }
                    }
                    if ((b.left != nullnode && b.right != nullnode) || (b.right != nullnode))
                    {
                        if (f.left == p)
                        {
                            b.color = f.color;
                            f.color = b.right.color = black;
                            root = rotate(f, ll);
                        }
                        else if (f.right == p)
                        {
                            b.color = f.color;
                            f.color = b.left.color = black;
                            root = rotate(f, rr);
                        }
                    }
                    if (b.left == nullnode && b.right == nullnode)
                    {
                        if (f.color == red)
                        {
                            f.color = black;
                            b.color = red;
                        }
                        else if (f.color == black)
                        {
                            b.color = red;

                            let t = f;
                            while(t != root){
                                f = t.parent;
                                if (f.left == t)
                                {
                                    b = f.right;
                                }
                                if (f.right == t)
                                {
                                    b = f.left;
                                }
                                
                                if (b.left.color == black && b.right.color == black){
                                    if (f.color == red){
                                        b.color = red;
                                        f.color = black;
                                        break
                                    }
                                    if (f.color == black){
                                        b.color = red;
                                        t = f;
                                        continue;
                                    }
                                }
                                if (f.left == t){
                                    if (b.right.color == red){
                                        b.right.color = black;
                                        root = rotate(f, ll);
                                        break
                                    }else if (b.right.color == black && b.left.color == red){
                                        b.color = b.left.color;
                                        b.left.color = black;
                                        root = rotate(b, rr);
                                        continue;
                                    }
                                }
                                if (f.right == t){
                                    if (b.left.color == red){
                                        b.left.color = black;
                                        root = rotate(f, rr);
                                        break
                                    }else if (b.left.color == black && b.right.color == red){
                                        b.color = b.right.color;
                                        b.right.color = black;
                                        root = rotate(b, ll);
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (p.parent.left == p)
            {
                p.parent.left = nullnode;
            }
            if (p.parent.right == p)
            {
                p.parent.right = nullnode;
            }

            return root;
        }

        function deep(root)
        {
            if(root == nullnode)
            {
                return 0
            }
            let l_deep = deep(root.left)+1
            let r_deep = deep(root.right)+1
            return l_deep >= r_deep ? l_deep : r_deep
        }

        function judge_nature_4(t)
        {
            if (t == nullnode)
            {
                return true;
            }
            if (t.color == red)
            {
                if (t.left != nullnode && t.left.color != black)
                {
                    return false;
                }
                if (t.right != nullnode && t.right.color != black)
                {
                    return false;
                }
            }
            return judge_nature_4(t.left) && judge_nature_4(t.right);
        }

        function judge_nature_5_get_height(t)
        {
            if (t == nullnode)
            {
                return true;
            }
            l_height = judge_nature_5_get_height(t.left);
            r_height = judge_nature_5_get_height(t.right);
            return t.color == black ? Math.max(l_height, r_height) + 1 : Math.max(l_height, r_height);
        }

        function judge_nature_5(t)
        {
            if (t == nullnode)
            {
                return true;
            }
            let l_h = judge_nature_5_get_height(t.left);
            let r_h = judge_nature_5_get_height(t.right);
            if (l_h != r_h)
            {
                return false;
            }
            return judge_nature_5(t.left) && judge_nature_5(t.right);
        }

        var t = init()

        var width = window.innerWidth
        var height = window.innerHeight

        var stage = new Konva.Stage({
            container: 'box',
            width: width,
            height: height
        })

        var layer = new Konva.Layer()

        function create_arrow(arx, ary, pox, poy){
            let arrow = new Konva.Arrow({
                x: arx,
                y: ary,
                points: [0, 0, pox, poy],
                pointerLength: 10,
                pointerWidth: 10,
                fill: 'black',
                stroke: 'black',
                strokeWidth: 2
            })
            return arrow
        }

        function draw(root, cex, cey) {
            if(root == nullnode || root.parent == nullnode)
            {
                return root
            }
            if(root.parent == root){
                cex = width / 2
                cey = 50
            }
            if(root.parent.left == root){
                // 根据深度偏移距离使得节点图形不重叠
                cex = cex - (60 + (deep(root)-1)*30)
                cey = cey + 60
            }
            if(root.parent.right == root){
                cex = cex + (60 + (deep(root)-1)*30)
                cey = cey + 60
            }
            if(root.color == red){
                cecol = '#ff3535'
            }
            if(root.color == black){
                cecol = '#000000'
            }

            var group_base = new Konva.Group({
                draggable: true
            })
            var circle = new Konva.Circle({
                x: cex,
                y: cey,
                radius: 20,
                fill: cecol,
                stroke: 'black',
                strokeWidth: 1
            })
            var text = new Konva.Text({
                x: circle.x() - circle.radius(),
                y: circle.y() - circle.radius(),
                text: root.data,
                fontSize: 24,
                fill: '#ffffff',
                padding: 12 - (String(root.data).length - 1) * 4,
                align: 'center',
            })
            group_base.add(circle)
            group_base.add(text)
            
            root.group = group_base
            layer.add(root.group)
                
            pa_cex = root.parent.group.children[0].attrs.x
            pa_cey = root.parent.group.children[0].attrs.y
            pa_rad = root.parent.group.children[0].attrs.radius
            if(root.parent.left == root){
                // 得到父亲和当前相对的圆环上的两个坐标向量
                let f_ring_vec = new vector(pa_cex-3, pa_cey+3, pa_rad, 135)
                let p_ring_vec = new vector(cex+3, cey-3, circle.radius(), -45)
                // 当前向量矩阵相减父亲向量得到箭头终点的坐标向量
                let [pox, poy] = new matrix_2by2().subtraction(p_ring_vec, f_ring_vec)
                // 生成箭头图形赋值给当前的父亲节点
                root.parent.left_arrow = create_arrow(f_ring_vec.x, f_ring_vec.y, pox, poy)
                // 保存父亲向量原点和箭头向量
                root.left_points = [f_ring_vec.x, f_ring_vec.y, pox, poy]

                layer.add(root.parent.left_arrow)
            }
            if(root.parent.right == root){
                let f_ring_vec = new vector(pa_cex+3, pa_cey+3, pa_rad, 45)
                let p_ring_vec = new vector(cex-3, cey-3, circle.radius(), -135)
                let [pox, poy] = new matrix_2by2().subtraction(p_ring_vec, f_ring_vec)

                root.parent.right_arrow = create_arrow(f_ring_vec.x, f_ring_vec.y, pox, poy)
                root.right_points = [f_ring_vec.x, f_ring_vec.y, pox, poy]

                layer.add(root.parent.right_arrow)
            }

            draw(root.left, cex, cey)
            draw(root.right, cex, cey)
        }
        
        // 拖拽实现箭头连接二叉树的节点
        function drag(t) {
            if(t == nullnode || (t.left == nullnode && t.right == nullnode)) {
                return
            }
            if(t.left != nullnode){
                var [l_arx, l_ary, l_pox, l_poy] = t.left.left_points
            }
            if(t.right != nullnode){
                var [r_arx, r_ary, r_pox, r_poy] = t.right.right_points
            }
            t.group.on('dragmove', () => {
                if(t.left != nullnode){
                    t.left_arrow.points([t.group.x(), t.group.y(), t.left.group.x() + l_pox, t.left.group.y() + l_poy]);
                    // [l_arx, l_ary] 当前节点的圆环坐标向量
                    // [l_pox, l_poy] 以[l_arx, l_ary]为原点的向量
                    // [l_son_cex, l_son_cey] 当前节点的相对儿子节点的圆环坐标向量
                    // [t.group.x(), t.group.y()] 移动的线性增加向量
                    // [new_l_arx, new_l_ary] 移动后的当前节点的圆环新坐标向量
                    // [new_l_pox, new_l_poy] 移动后的以[new_l_arx, new_l_ary]为原点的向量
                    let [l_son_cex, l_son_cey] = new matrix_2by2().addition(new vector(l_arx, l_ary), new vector(l_pox, l_poy))
                    let [new_l_arx, new_l_ary] = new matrix_2by2().addition(new vector(l_arx, l_ary), new vector(t.group.x(), t.group.y()))
                    let [new_l_pox, new_l_poy] = new matrix_2by2().subtraction(new vector(l_son_cex, l_son_cey), new vector(new_l_arx, new_l_ary))
                    t.left.left_points = [new_l_arx, new_l_ary, new_l_pox, new_l_poy]
                }
                
                if(t.right != nullnode){
                    t.right_arrow.points([t.group.x(), t.group.y(), t.right.group.x() + r_pox, t.right.group.y() + r_poy]);
                    let [r_son_cex, r_son_cey] = new matrix_2by2().addition(new vector(r_arx, r_ary), new vector(r_pox, r_poy))
                    let [new_r_arx, new_r_ary] = new matrix_2by2().addition(new vector(r_arx, r_ary), new vector(t.group.x(), t.group.y()))
                    let [new_r_pox, new_r_poy] = new matrix_2by2().subtraction(new vector(r_son_cex, r_son_cey), new vector(new_r_arx, new_r_ary))  
                    t.right.right_points = [new_r_arx, new_r_ary, new_r_pox, new_r_poy]
                }
                
                layer.batchDraw();
            });
            if(t.left != nullnode){
                t.left.group.on('dragmove', () => {
                    t.left_arrow.points([t.group.x(), t.group.y(), t.left.group.x() + l_pox, t.left.group.y() + l_poy]);
                    layer.batchDraw();
                });
            }
            if(t.right != nullnode){
                t.right.group.on('dragmove', () => {
                    t.right_arrow.points([t.group.x(), t.group.y(), t.right.group.x() + r_pox, t.right.group.y() + r_poy]);
                    layer.batchDraw();
                });
            }
            drag(t.left)
            drag(t.right)
        }

        drag(t)
        
        stage.add(layer)

        function get_p_arrow(p_node, direction, layer_local) {
            if(direction == 'left'){
                var p_node_arrow = p_node.left_arrow
            }
            if(direction == 'right'){
                var p_node_arrow = p_node.right_arrow
            }
            
            if(p_node_arrow == null){
                let p_cex = p_node.group.children[0].attrs.x
                let p_cey = p_node.group.children[0].attrs.y
                let p_radius = p_node.group.children[0].attrs.radius
                let p_angle = 0;
                [p_cex, p_cey, p_angle] = (direction == 'left') ? [p_cex-3, p_cey+3, 135] : (direction == 'right') ? [p_cex+3, p_cey+3, 45] : [p_cex, p_cey, 0]
                var p_ring_vec = new vector(p_cex, p_cey, p_radius, p_angle)
                var arrow_local = new Konva.Arrow({
                    x: p_ring_vec.x,
                    y: p_ring_vec.y,
                    points: [0, 0, 0, 0],
                    pointerLength: 10,
                    pointerWidth: 10,
                    fill: 'black',
                    stroke: 'black',
                    strokeWidth: 2
                })
                layer_local.add(arrow_local)
                return arrow_local
            }

            var Arrow_list = layer_local.find('Arrow')
            for (let key in Arrow_list) {
                if(Arrow_list[key] == Arrow_list.length){
                    break
                }
                if(p_node_arrow.attrs.x == Arrow_list[key].attrs.x && p_node_arrow.attrs.y == Arrow_list[key].attrs.y){
                    var arrow_local = Arrow_list[key]
                }
            }
            return arrow_local
        }

        function get_tween_para(arrow_local, next_node) {
            if(next_node == null){
                var [pox, poy] = [0, 0]
            }else{
                var n_pox = next_node.group.children[0].attrs.x
                var n_poy = next_node.group.children[0].attrs.y
                var n_radius = next_node.group.children[0].attrs.radius
                // 目标节点的坐标矩阵相减箭头原点得到相对位置的差值矩阵
                var [cx, cy] = new matrix_2by2().subtraction(new vector(n_pox, n_poy), new vector(arrow_local.attrs.x, arrow_local.attrs.y));
                // 判断以目标节点为中心相对箭头原点的方向
                // 右下角 45   // cx < 0 && cy < 0
                // 左下角 135  // cx < 0 && cy > 0
                // 左上角 -135 // cx > 0 && cy > 0
                // 右上角 -45  // cx > 0 && cy < 0
                var n_angle = (cx < 0 && cy < 0) ? 45 : (cx < 0 && cy > 0) ? 135 : (cx > 0 && cy > 0) ? -135 : (cx > 0 && cy < 0) ? -45 : 0;
                var [pox, poy] = new matrix_2by2().subtraction(new vector(n_pox, n_poy, n_radius, n_radius), new vector(arrow_local.attrs.x, arrow_local.attrs.y))
            }
            return [pox, poy]
        }

        function arrow_cartoon(p_node, direction, n_node, timeline, layer_local) {
            var arrow_local = get_p_arrow(p_node, direction, layer_local)
            var [pox, poy] = get_tween_para(arrow_local, n_node)
            timeline.to(arrow_local, 1, {
                konva: {
                    points: [0, 0, pox, poy],
                }
            })
        }

        function rotate_cartoon(kg, direction) {
            
            var layer_local = layer.clone();
            handle.drag_switch(layer)
            handle.drag_switch(layer_local)
            stage.add(layer_local);
            var tl = new TimelineLite({
                onStart: () => {
                    layer.hide();
                },
                onComplete: () => {
                    layer_local.destroy();
                    layer.show();
                    layer.batchDraw();
                },
            });

            let kf, kgf;
            if (direction == ll)
            {
                kf = kg.right;
                //kg.right = kf.left;
                arrow_cartoon(kg, 'right', kf.left, tl, layer_local)

                //  kf.left = kg
                arrow_cartoon(kf, 'left', kg, tl, layer_local)
                /* if(kf.left != nullnode)
                {
                    kf.left.parent = kg;
                }
                kf.left = kg; */
                
            }
            /* if (direction == rr)
            {
                kf = kg.left;
                kg.left = kf.right;
                if(kf.right != nullnode)
                {
                    kf.right.parent = kg;
                }
                kf.right = kg;
            }

            if (kg.parent == kg)
            {
                kf.parent = kf;
                kg.parent = kf;
            }
            else
            {
                kgf = kg.parent;
                if (kgf.left == kg)
                {
                    kgf.left = kf;
                }
                if (kgf.right == kg)
                {
                    kgf.right = kf;
                }
                kf.parent = kgf;
                kg.parent = kf;

                while (kf.parent != kf)
                {
                    kf = kf.parent;
                }
            }

            return kf; */
        }

        // 2021 4 23 本人应该在车底，不应该在车里
        // Local complete time : Apr 22 2021
        // Author: akinokoika
    </script>
</script>
</body>
</html>